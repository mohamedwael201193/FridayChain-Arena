#![cfg_attr(target_arch = "wasm32", no_main)]

// Copyright (c) FridayChain Arena Contributors
// SPDX-License-Identifier: MIT

//! Smart contract for FridayChain Arena.
//!
//! Implements the Linera `Contract` trait. Every user action (register, place cell,
//! start/end tournament) is processed here — the contract is the ONLY source of truth.
//!
//! ## Chain Roles
//!
//! - **Hub chain**: Manages global player registry, tournament lifecycle, and leaderboard.
//!   Emits events on the "tournament" stream for subscriber chains.
//! - **Player chains**: Handle local game state, validate moves, and sync results to Hub
//!   via cross-chain messages.

mod state;

use self::state::ArenaState;
use fridaychain_arena::{
    sudoku, ArenaEvent, ArenaResponse, BoardCompletedResponse,
    CachedLeaderboard, CellClearedResponse, CellPlacedResponse, ErrorResponse,
    FridayChainArenaAbi, InstantiationArgument, LeaderboardEntry, LeaderboardRequestedResponse,
    Message, Operation, PlayerGameState, PlayerInfo, PlayerRegisteredResponse, SubscribedResponse,
    Tournament, TournamentEndedResponse, TournamentStartedResponse, UsernameUpdatedResponse,
    TOURNAMENT_STREAM,
};
use linera_sdk::{
    linera_base_types::{AccountOwner, ChainId, StreamName, WithContractAbi},
    Contract, ContractRuntime,
};

/// The application contract.
pub struct FridayChainArenaContract {
    state: ArenaState,
    runtime: ContractRuntime<Self>,
}

linera_sdk::contract!(FridayChainArenaContract);

impl WithContractAbi for FridayChainArenaContract {
    type Abi = FridayChainArenaAbi;
}

impl Contract for FridayChainArenaContract {
    type Message = Message;
    type InstantiationArgument = InstantiationArgument;
    type Parameters = ();
    type EventValue = ArenaEvent;

    async fn load(runtime: ContractRuntime<Self>) -> Self {
        let state = ArenaState::load(runtime.root_view_storage_context())
            .await
            .expect("Failed to load state");
        Self { state, runtime }
    }

    async fn instantiate(&mut self, arg: InstantiationArgument) {
        self.state.hub_chain_id.set(Some(arg.hub_chain_id));
        // The creator is the admin
        let admin = self
            .runtime
            .authenticated_signer()
            .expect("Instantiation must be authenticated");
        self.state.admin_owner.set(Some(admin));
    }

    async fn execute_operation(&mut self, operation: Operation) -> ArenaResponse {
        match operation {
            Operation::RegisterPlayer { discord_username } => {
                self.handle_register_player(discord_username).await
            }
            Operation::UpdateUsername {
                new_discord_username,
            } => self.handle_update_username(new_discord_username).await,
            Operation::PlaceCell { row, col, value } => {
                self.handle_place_cell(row, col, value).await
            }
            Operation::ClearCell { row, col } => self.handle_clear_cell(row, col).await,
            Operation::SubscribeToHub => self.handle_subscribe_to_hub().await,
            Operation::RequestLeaderboard { limit } => {
                self.handle_request_leaderboard(limit).await
            }
            Operation::StartTournament {
                seed,
                duration_secs,
            } => self.handle_start_tournament(seed, duration_secs).await,
            Operation::EndTournament => self.handle_end_tournament().await,
        }
    }

    async fn execute_message(&mut self, message: Message) {
        match message {
            Message::SyncPlayer(player_info) => {
                self.handle_sync_player(player_info).await;
            }
            Message::SyncCellPlacement {
                wallet,
                row,
                col,
                value,
                timestamp_micros,
            } => {
                self.handle_sync_cell_placement(wallet, row, col, value, timestamp_micros)
                    .await;
            }
            Message::SyncBoardComplete {
                wallet,
                completion_time_micros,
                penalty_count,
                move_count,
            } => {
                self.handle_sync_board_complete(
                    wallet,
                    completion_time_micros,
                    penalty_count,
                    move_count,
                )
                .await;
            }
            Message::LeaderboardRequest {
                requester_chain,
                limit,
            } => {
                self.handle_leaderboard_request(requester_chain, limit)
                    .await;
            }
            Message::LeaderboardResponse {
                entries,
                tournament_id,
                is_active,
            } => {
                self.handle_leaderboard_response(entries, tournament_id, is_active)
                    .await;
            }
            Message::TournamentStarted {
                tournament_id,
                seed,
                start_time_micros,
                end_time_micros,
            } => {
                self.handle_tournament_started_msg(
                    tournament_id,
                    seed,
                    start_time_micros,
                    end_time_micros,
                )
                .await;
            }
            Message::TournamentEnded {
                tournament_id,
                final_rankings,
            } => {
                self.handle_tournament_ended_msg(tournament_id, final_rankings)
                    .await;
            }
        }
    }

    async fn store(self) {
        self.state.save().await.expect("Failed to save state");
    }
}

// ---------------------------------------------------------------------------
// Operation Handlers
// ---------------------------------------------------------------------------

impl FridayChainArenaContract {
    /// Get the Hub chain ID.
    fn hub_chain_id(&self) -> ChainId {
        self.state
            .hub_chain_id
            .get()
            .expect("Hub chain ID not set")
    }

    /// Check if the current chain is the Hub.
    fn is_hub(&self) -> bool {
        self.runtime.chain_id() == self.hub_chain_id()
    }

    /// Assert the caller is the admin.
    fn assert_admin(&self) {
        let signer = self
            .runtime
            .authenticated_signer()
            .expect("Operation must be authenticated");
        let admin = self
            .state
            .admin_owner
            .get()
            .expect("Admin not set");
        assert_eq!(signer, admin, "Only the admin can perform this operation");
    }

    /// Get the authenticated signer for the current operation.
    fn signer(&self) -> AccountOwner {
        self.runtime
            .authenticated_signer()
            .expect("Operation must be authenticated")
    }

    /// Send a cross-chain message to the Hub if we're not already the Hub.
    fn send_to_hub(&mut self, message: Message) {
        let hub = self.hub_chain_id();
        if self.runtime.chain_id() != hub {
            self.runtime
                .prepare_message(message)
                .with_authentication()
                .send_to(hub);
        }
    }

    /// Get the current system time in microseconds.
    fn now_micros(&mut self) -> u64 {
        self.runtime.system_time().micros()
    }

    // ── RegisterPlayer ───────────────────────────────────────────────────

    async fn handle_register_player(&mut self, discord_username: String) -> ArenaResponse {
        if discord_username.is_empty() || discord_username.len() > 32 {
            return ArenaResponse::Error(ErrorResponse {
                message: "Discord username must be 1-32 characters".to_string(),
            });
        }

        let wallet = self.signer();
        let now = self.now_micros();

        // Check if already registered
        if self.state.players.contains_key(&wallet).await.unwrap_or(false) {
            return ArenaResponse::Error(ErrorResponse {
                message: "Player already registered. Use UpdateUsername to change.".to_string(),
            });
        }

        let player_info = PlayerInfo {
            wallet,
            discord_username: discord_username.clone(),
            registered_at_micros: now,
        };

        // Store locally
        self.state
            .players
            .insert(&wallet, player_info.clone())
            .expect("Failed to insert player");

        // Sync to Hub
        self.send_to_hub(Message::SyncPlayer(player_info));

        ArenaResponse::PlayerRegistered(PlayerRegisteredResponse {
            wallet,
            discord_username,
        })
    }

    // ── UpdateUsername ────────────────────────────────────────────────────

    async fn handle_update_username(&mut self, new_discord_username: String) -> ArenaResponse {
        if new_discord_username.is_empty() || new_discord_username.len() > 32 {
            return ArenaResponse::Error(ErrorResponse {
                message: "Discord username must be 1-32 characters".to_string(),
            });
        }

        let wallet = self.signer();

        let existing = self.state.players.get(&wallet).await.unwrap_or(None);
        match existing {
            Some(mut player) => {
                player.discord_username = new_discord_username.clone();
                self.state
                    .players
                    .insert(&wallet, player.clone())
                    .expect("Failed to update player");

                // Sync to Hub
                self.send_to_hub(Message::SyncPlayer(player));

                ArenaResponse::UsernameUpdated(UsernameUpdatedResponse {
                    wallet,
                    new_discord_username,
                })
            }
            None => ArenaResponse::Error(ErrorResponse {
                message: "Player not registered. Register first.".to_string(),
            }),
        }
    }

    // ── PlaceCell ────────────────────────────────────────────────────────

    async fn handle_place_cell(&mut self, row: u8, col: u8, value: u8) -> ArenaResponse {
        let wallet = self.signer();
        let now = self.now_micros();

        // Check player is registered
        let player = match self.state.players.get(&wallet).await.unwrap_or(None) {
            Some(p) => p,
            None => {
                return ArenaResponse::Error(ErrorResponse {
                    message: "Player not registered".to_string(),
                });
            }
        };

        // Check tournament is active
        let tournament = match self.state.get_active_tournament() {
            Some(t) => t.clone(),
            None => {
                return ArenaResponse::Error(ErrorResponse {
                    message: "No active tournament".to_string(),
                });
            }
        };

        // Check within time window
        if now < tournament.start_time_micros || now > tournament.end_time_micros {
            return ArenaResponse::Error(ErrorResponse {
                message: "Tournament time window has expired".to_string(),
            });
        }

        // Validate basic bounds
        if row > 8 || col > 8 || value < 1 || value > 9 {
            return ArenaResponse::Error(ErrorResponse {
                message: "Invalid cell coordinates or value".to_string(),
            });
        }

        let r = row as usize;
        let c = col as usize;

        // Load or initialize player game state
        let puzzle = match self.state.current_puzzle.get() {
            Some(board) => board.clone(),
            None => {
                return ArenaResponse::Error(ErrorResponse {
                    message: "Puzzle not loaded for this tournament".to_string(),
                });
            }
        };

        let mut game_state = match self.state.player_games.get(&wallet).await.unwrap_or(None) {
            Some(gs) => gs,
            None => {
                // First move — initialize from puzzle
                let mut gs = PlayerGameState::new(&puzzle.puzzle);
                gs.start_time_micros = now;
                gs
            }
        };

        // Check board not already completed
        if game_state.completed {
            return ArenaResponse::Error(ErrorResponse {
                message: "Board already completed".to_string(),
            });
        }

        // Check not a given cell
        if game_state.given_mask[r][c] {
            return ArenaResponse::Error(ErrorResponse {
                message: "Cannot modify a given cell".to_string(),
            });
        }

        // Validate placement per Sudoku rules
        let valid = sudoku::validate_placement(&game_state.board, r, c, value);

        if !valid {
            game_state.penalty_count += 1;
        }

        // Place the value regardless (allows players to correct themselves)
        game_state.board[r][c] = value;
        game_state.move_count += 1;

        // Check if board is now complete
        let board_complete = game_state.check_complete(&puzzle.solution);

        if board_complete {
            game_state.completed = true;
            game_state.completion_time_micros = Some(now);
            game_state.score =
                game_state.calculate_score(game_state.start_time_micros, now);

            // Sync completion to Hub
            self.send_to_hub(Message::SyncBoardComplete {
                wallet,
                completion_time_micros: now,
                penalty_count: game_state.penalty_count,
                move_count: game_state.move_count,
            });
        }

        // Save game state
        self.state
            .player_games
            .insert(&wallet, game_state.clone())
            .expect("Failed to save game state");

        // Sync cell placement to Hub (for move tracking)
        self.send_to_hub(Message::SyncCellPlacement {
            wallet,
            row,
            col,
            value,
            timestamp_micros: now,
        });

        if board_complete {
            ArenaResponse::BoardCompleted(BoardCompletedResponse {
                completion_time_micros: now,
                penalty_count: game_state.penalty_count,
                score: game_state.score,
            })
        } else {
            ArenaResponse::CellPlaced(CellPlacedResponse {
                row,
                col,
                value,
                valid,
                penalty_count: game_state.penalty_count,
                board_complete: false,
            })
        }
    }

    // ── ClearCell ────────────────────────────────────────────────────────

    async fn handle_clear_cell(&mut self, row: u8, col: u8) -> ArenaResponse {
        let wallet = self.signer();
        let now = self.now_micros();

        // Check tournament is active
        let tournament = match self.state.get_active_tournament() {
            Some(t) => t.clone(),
            None => {
                return ArenaResponse::Error(ErrorResponse {
                    message: "No active tournament".to_string(),
                });
            }
        };

        if now < tournament.start_time_micros || now > tournament.end_time_micros {
            return ArenaResponse::Error(ErrorResponse {
                message: "Tournament time window has expired".to_string(),
            });
        }

        if row > 8 || col > 8 {
            return ArenaResponse::Error(ErrorResponse {
                message: "Invalid cell coordinates".to_string(),
            });
        }

        let r = row as usize;
        let c = col as usize;

        let mut game_state = match self.state.player_games.get(&wallet).await.unwrap_or(None) {
            Some(gs) => gs,
            None => {
                return ArenaResponse::Error(ErrorResponse {
                    message: "No game in progress".to_string(),
                });
            }
        };

        if game_state.completed {
            return ArenaResponse::Error(ErrorResponse {
                message: "Board already completed".to_string(),
            });
        }

        if game_state.given_mask[r][c] {
            return ArenaResponse::Error(ErrorResponse {
                message: "Cannot clear a given cell".to_string(),
            });
        }

        game_state.board[r][c] = 0;

        self.state
            .player_games
            .insert(&wallet, game_state)
            .expect("Failed to save game state");

        ArenaResponse::CellCleared(CellClearedResponse { row, col })
    }

    // ── SubscribeToHub ───────────────────────────────────────────────────

    async fn handle_subscribe_to_hub(&mut self) -> ArenaResponse {
        let hub = self.hub_chain_id();

        // Subscribe to the Hub's tournament event stream
        self.runtime.subscribe_to_events(
            hub,
            self.runtime.application_id().forget_abi(),
            StreamName(TOURNAMENT_STREAM.to_vec()),
        );

        ArenaResponse::Subscribed(SubscribedResponse {
            hub_chain_id: hub,
        })
    }

    // ── RequestLeaderboard ───────────────────────────────────────────────

    async fn handle_request_leaderboard(&mut self, limit: Option<u32>) -> ArenaResponse {
        let hub = self.hub_chain_id();
        let requester_chain = self.runtime.chain_id();
        let limit = limit.unwrap_or(50).min(200);

        self.runtime
            .prepare_message(Message::LeaderboardRequest {
                requester_chain,
                limit,
            })
            .with_authentication()
            .send_to(hub);

        ArenaResponse::LeaderboardRequested(LeaderboardRequestedResponse {
            message: "Leaderboard request sent to Hub. Query cachedLeaderboard shortly."
                .to_string(),
        })
    }

    // ── StartTournament (Admin only, Hub only) ───────────────────────────

    async fn handle_start_tournament(&mut self, seed: u64, duration_secs: u64) -> ArenaResponse {
        self.assert_admin();

        if !self.is_hub() {
            return ArenaResponse::Error(ErrorResponse {
                message: "StartTournament can only be called on the Hub chain".to_string(),
            });
        }

        // Check no tournament is already active
        if let Some(t) = self.state.active_tournament.get() {
            if t.active {
                return ArenaResponse::Error(ErrorResponse {
                    message: "A tournament is already active. End it first.".to_string(),
                });
            }
        }

        let now = self.now_micros();
        let counter = *self.state.tournament_counter.get() + 1;
        self.state.tournament_counter.set(counter);

        let start_time = now;
        let end_time = now + (duration_secs * 1_000_000);

        // Generate the puzzle from seed
        let puzzle = sudoku::generate_puzzle(seed).expect("Failed to generate Sudoku puzzle");
        self.state.current_puzzle.set(Some(puzzle));

        let tournament = Tournament {
            id: counter,
            seed,
            start_time_micros: start_time,
            end_time_micros: end_time,
            active: true,
            total_players: 0,
            total_completions: 0,
        };

        self.state.active_tournament.set(Some(tournament));

        // Clear previous leaderboard
        self.state
            .leaderboard
            .clear();

        // Emit event on the tournament stream for all subscribers
        let event = ArenaEvent::TournamentStarted {
            tournament_id: counter,
            seed,
            start_time_micros: start_time,
            end_time_micros: end_time,
        };
        self.runtime.emit(
            StreamName(TOURNAMENT_STREAM.to_vec()),
            &event,
        );

        // Also log the event
        self.state.event_log.push(event);
        let ec = *self.state.event_counter.get() + 1;
        self.state.event_counter.set(ec);

        ArenaResponse::TournamentStarted(TournamentStartedResponse {
            tournament_id: counter,
            seed,
            start_time_micros: start_time,
            end_time_micros: end_time,
        })
    }

    // ── EndTournament (Admin only, Hub only) ─────────────────────────────

    async fn handle_end_tournament(&mut self) -> ArenaResponse {
        self.assert_admin();

        if !self.is_hub() {
            return ArenaResponse::Error(ErrorResponse {
                message: "EndTournament can only be called on the Hub chain".to_string(),
            });
        }

        let mut tournament = match self.state.active_tournament.get().cloned() {
            Some(t) if t.active => t,
            _ => {
                return ArenaResponse::Error(ErrorResponse {
                    message: "No active tournament to end".to_string(),
                });
            }
        };

        tournament.active = false;

        // Get final rankings
        let final_rankings = self.state.get_sorted_leaderboard(200).await;

        let total_players = tournament.total_players;
        let total_completions = tournament.total_completions;
        let tournament_id = tournament.id;

        // Archive the tournament
        self.state.past_tournaments.push(tournament.clone());
        self.state.active_tournament.set(Some(tournament));

        // Emit tournament ended event
        let event = ArenaEvent::TournamentEnded {
            tournament_id,
            final_rankings: final_rankings.clone(),
        };
        self.runtime.emit(
            StreamName(TOURNAMENT_STREAM.to_vec()),
            &event,
        );

        self.state.event_log.push(event);
        let ec = *self.state.event_counter.get() + 1;
        self.state.event_counter.set(ec);

        ArenaResponse::TournamentEnded(TournamentEndedResponse {
            tournament_id,
            total_players,
            total_completions,
        })
    }
}

// ---------------------------------------------------------------------------
// Message Handlers
// ---------------------------------------------------------------------------

impl FridayChainArenaContract {
    /// Handle SyncPlayer on Hub: add/update player in global registry.
    async fn handle_sync_player(&mut self, player_info: PlayerInfo) {
        let wallet = player_info.wallet;
        let is_new = !self
            .state
            .players
            .contains_key(&wallet)
            .await
            .unwrap_or(false);

        self.state
            .players
            .insert(&wallet, player_info.clone())
            .expect("Failed to sync player");

        if is_new {
            let count = *self.state.player_count.get() + 1;
            self.state.player_count.set(count);

            // Emit player registered event
            let event = ArenaEvent::PlayerRegistered {
                wallet,
                discord_username: player_info.discord_username,
            };
            self.state.event_log.push(event);
            let ec = *self.state.event_counter.get() + 1;
            self.state.event_counter.set(ec);
        }
    }

    /// Handle SyncCellPlacement on Hub: track move for auditing.
    async fn handle_sync_cell_placement(
        &mut self,
        wallet: AccountOwner,
        _row: u8,
        _col: u8,
        _value: u8,
        _timestamp_micros: u64,
    ) {
        // Update active tournament player count if needed
        if let Some(mut tournament) = self.state.active_tournament.get().cloned() {
            if tournament.active {
                // Check if this is a new player for this tournament
                let has_entry = self
                    .state
                    .leaderboard
                    .contains_key(&wallet)
                    .await
                    .unwrap_or(false);

                if !has_entry {
                    // Get username
                    let username = self
                        .state
                        .players
                        .get(&wallet)
                        .await
                        .unwrap_or(None)
                        .map(|p| p.discord_username.clone())
                        .unwrap_or_else(|| "Unknown".to_string());

                    // Create initial leaderboard entry
                    let entry = LeaderboardEntry {
                        wallet,
                        discord_username: username,
                        score: 0,
                        completion_time_micros: 0,
                        penalty_count: 0,
                        move_count: 1,
                        completed: false,
                    };
                    self.state
                        .leaderboard
                        .insert(&wallet, entry)
                        .expect("Failed to create leaderboard entry");

                    tournament.total_players += 1;
                    self.state.active_tournament.set(Some(tournament));
                } else {
                    // Update move count
                    if let Some(mut entry) = self
                        .state
                        .leaderboard
                        .get(&wallet)
                        .await
                        .unwrap_or(None)
                    {
                        entry.move_count += 1;
                        self.state
                            .leaderboard
                            .insert(&wallet, entry)
                            .expect("Failed to update move count");
                    }
                }
            }
        }
    }

    /// Handle SyncBoardComplete on Hub: update leaderboard.
    async fn handle_sync_board_complete(
        &mut self,
        wallet: AccountOwner,
        completion_time_micros: u64,
        penalty_count: u32,
        move_count: u32,
    ) {
        let username = self
            .state
            .players
            .get(&wallet)
            .await
            .unwrap_or(None)
            .map(|p| p.discord_username.clone())
            .unwrap_or_else(|| "Unknown".to_string());

        let tournament = match self.state.active_tournament.get().cloned() {
            Some(t) => t,
            None => return,
        };

        // Calculate score
        let elapsed_secs =
            completion_time_micros.saturating_sub(tournament.start_time_micros) / 1_000_000;
        let time_penalty = elapsed_secs.saturating_mul(10);
        let move_pen = (penalty_count as u64).saturating_mul(200);
        let score = 10_000u64
            .saturating_sub(time_penalty)
            .saturating_sub(move_pen);

        let entry = LeaderboardEntry {
            wallet,
            discord_username: username,
            score,
            completion_time_micros,
            penalty_count,
            move_count,
            completed: true,
        };

        self.state
            .leaderboard
            .insert(&wallet, entry.clone())
            .expect("Failed to update leaderboard");

        self.state.leaderboard_log.push(entry);

        // Update tournament completion count
        let mut tournament = tournament;
        tournament.total_completions += 1;
        self.state.active_tournament.set(Some(tournament));

        // Emit leaderboard update event
        let entries = self.state.get_sorted_leaderboard(50).await;
        let event = ArenaEvent::LeaderboardUpdated { entries };
        self.runtime.emit(
            StreamName(TOURNAMENT_STREAM.to_vec()),
            &event,
        );
    }

    /// Handle LeaderboardRequest on Hub: send back sorted leaderboard.
    async fn handle_leaderboard_request(&mut self, requester_chain: ChainId, limit: u32) {
        let entries = self.state.get_sorted_leaderboard(limit).await;

        let tournament_id = self
            .state
            .active_tournament
            .get()
            .as_ref()
            .map(|t| t.id)
            .unwrap_or(0);
        let is_active = self
            .state
            .active_tournament
            .get()
            .as_ref()
            .map(|t| t.active)
            .unwrap_or(false);

        self.runtime
            .prepare_message(Message::LeaderboardResponse {
                entries,
                tournament_id,
                is_active,
            })
            .with_authentication()
            .send_to(requester_chain);
    }

    /// Handle LeaderboardResponse on player chain: cache the result.
    async fn handle_leaderboard_response(
        &mut self,
        entries: Vec<LeaderboardEntry>,
        tournament_id: u64,
        is_active: bool,
    ) {
        let now = self.now_micros();
        self.state
            .cached_leaderboard
            .set(Some(CachedLeaderboard {
                entries,
                tournament_id,
                is_active,
                fetched_at_micros: now,
            }));
    }

    /// Handle TournamentStarted message on player chain.
    async fn handle_tournament_started_msg(
        &mut self,
        tournament_id: u64,
        seed: u64,
        start_time_micros: u64,
        end_time_micros: u64,
    ) {
        let tournament = Tournament {
            id: tournament_id,
            seed,
            start_time_micros,
            end_time_micros,
            active: true,
            total_players: 0,
            total_completions: 0,
        };
        self.state.active_tournament.set(Some(tournament));

        // Generate the puzzle locally from the same seed
        let puzzle = sudoku::generate_puzzle(seed).expect("Failed to generate puzzle from seed");
        self.state.current_puzzle.set(Some(puzzle));

        // Clear previous game states
        self.state.player_games.clear();
        self.state.cached_leaderboard.set(None);
    }

    /// Handle TournamentEnded message on player chain.
    async fn handle_tournament_ended_msg(
        &mut self,
        tournament_id: u64,
        final_rankings: Vec<LeaderboardEntry>,
    ) {
        // Mark tournament as inactive
        if let Some(mut t) = self.state.active_tournament.get().cloned() {
            if t.id == tournament_id {
                t.active = false;
                self.state.active_tournament.set(Some(t));
            }
        }

        // Cache the final rankings
        let now = self.now_micros();
        self.state
            .cached_leaderboard
            .set(Some(CachedLeaderboard {
                entries: final_rankings,
                tournament_id,
                is_active: false,
                fetched_at_micros: now,
            }));
    }
}
